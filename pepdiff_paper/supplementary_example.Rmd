---
title: "pepdiff: Supplementary Example Code"
author: "Dan MacLean"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: flatly
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 8
)
```

# Introduction

This supplementary document provides fully reproducible R code for the analyses presented in the pepdiff paper. We demonstrate the package using simulated phosphoproteomics datasets with known ground truth, enabling validation of sensitivity and false discovery rate.

# Setup

```{r packages}
library(pepdiff)
library(tidyverse)
library(cowplot)

set.seed(2026)
```

# Part 1: Factorial Design Example

## Experimental Design

We simulate a factorial phosphoproteomics experiment:

- **Treatment**: ctrl, drug (2 levels)
- **Timepoint**: 0h, 6h, 24h (3 levels)
- **Biological replicates**: 6 per condition
- **Total samples**: 2 × 3 × 6 = 36

## Peptide Parameters

Generate 500 peptides with heterogeneous Gamma-distributed abundances. The first 50 peptides have a true treatment effect (3-5 fold) that manifests only at the 24h timepoint.

```{r peptide-params}
n_peptides <- 500
n_true_positives <- 50

peptide_params <- tibble(
  peptide = paste0("pep_", sprintf("%04d", 1:n_peptides)),
  gene_id = paste0("gene_", sprintf("%03d", rep(1:100, each = 5))),

  # Gamma distribution parameters - higher shape = lower variance coefficient
  shape = runif(n_peptides, 4, 10),  # Increased from 1.5-6 to 4-10 for lower variance
  rate = runif(n_peptides, 0.05, 0.12),

  # True effect (only for first 50 peptides, only at 24h)
  # Stronger effect sizes (3-5 fold) to ensure detection
  true_effect = c(rep(TRUE, n_true_positives), rep(FALSE, n_peptides - n_true_positives)),
  effect_size = ifelse(true_effect, runif(n_peptides, 3.0, 5.0), 1.0),

  # Lower missingness for cleaner demonstration
  mean_abundance = shape / rate,
  miss_prob = pmax(0, 0.15 - 0.003 * mean_abundance)  # Reduced missingness
)

# Summary of parameters
peptide_params %>%
  group_by(true_effect) %>%
  summarise(
    n = n(),
    mean_effect_size = mean(effect_size),
    mean_miss_prob = mean(miss_prob),
    .groups = "drop"
  )
```

## Generate Simulated Data

```{r generate-data}
# Create experimental design grid
# 6 replicates per condition for adequate power
design_grid <- expand_grid(
  treatment = c("ctrl", "drug"),
  timepoint = c("0h", "6h", "24h"),
  bio_rep = 1:6
)

# Generate data for each peptide and sample
generate_sample <- function(shape, rate, effect_size, miss_prob,
                            treatment, timepoint) {
  # Draw from Gamma
  value <- rgamma(1, shape = shape, rate = rate)

  # Apply effect (multiplicative) only for drug at 24h
  if (treatment == "drug" && timepoint == "24h") {
    value <- value * effect_size
  }

  # Apply missingness (MNAR pattern)
  if (runif(1) < miss_prob) {
    value <- NA
  }

  return(value)
}

# Generate full dataset
simulated_data <- peptide_params %>%
  crossing(design_grid) %>%
  rowwise() %>%
  mutate(
    abundance = generate_sample(shape, rate, effect_size, miss_prob,
                                treatment, timepoint)
  ) %>%
  ungroup() %>%
  select(peptide, gene_id, treatment, timepoint, bio_rep, abundance)

# Check data characteristics
cat("Total observations:", nrow(simulated_data), "\n")
cat("Missing rate:", round(mean(is.na(simulated_data$abundance)) * 100, 1), "%\n")
```

## Save Simulated Data

```{r save-data}
# Save for reproducibility
write_csv(simulated_data, "simulated_phospho.csv")
write_csv(peptide_params, "peptide_params.csv")
```

# Data Import with pepdiff

```{r import-data}
dat <- read_pepdiff(
  "simulated_phospho.csv",
  id = "peptide",
  gene = "gene_id",
  value = "abundance",
  factors = c("treatment", "timepoint"),
  replicate = "bio_rep"
)

print(dat)
```

# Analysis: Stratified GLM

The primary analysis uses Gamma GLM with emmeans-based contrasts, stratified by timepoint.

```{r glm-analysis}
results_glm <- compare(
  dat,
  compare = "treatment",
  ref = "ctrl",
  within = "timepoint",
  method = "glm"
)

print(results_glm)
```

## Results by Timepoint

```{r results-by-timepoint}
results_glm$results %>%
  group_by(comparison) %>%
  summarise(
    n_significant = sum(significant),
    mean_fc = mean(fold_change[significant], na.rm = TRUE),
    .groups = "drop"
  )
```

## Validation Against Ground Truth

```{r validation-glm}
# Extract 24h results and merge with ground truth
res_24h_glm <- results_glm$results %>%
  filter(timepoint == "24h") %>%
  left_join(peptide_params %>% select(peptide, true_effect), by = "peptide")

# Calculate performance metrics
tp_glm <- sum(res_24h_glm$significant & res_24h_glm$true_effect, na.rm = TRUE)
fp_glm <- sum(res_24h_glm$significant & !res_24h_glm$true_effect, na.rm = TRUE)
fn_glm <- sum(!res_24h_glm$significant & res_24h_glm$true_effect, na.rm = TRUE)

cat("Stratified GLM Results (24h timepoint):\n")
cat("  True Positives:", tp_glm, "\n")
cat("  False Positives:", fp_glm, "\n")
cat("  False Negatives:", fn_glm, "\n")
cat("  Sensitivity:", round(tp_glm / (tp_glm + fn_glm), 3), "\n")
cat("  FDR:", round(fp_glm / (tp_glm + fp_glm), 3), "\n")
```

# Comparison: Log-Transform + Imputation + t-test

A conventional proteomics workflow:

1. Log2-transform abundances
2. Impute missing values (downshifted normal distribution)
3. Apply t-test at the 24h timepoint

Note: This approach requires knowing in advance which timepoint to analyse.

```{r conventional-workflow}
# Step 1: Log2 transform
log_data <- dat$data %>%
  mutate(log2_abundance = log2(value))

# Step 2: Impute missing values (downshifted normal)
# Perseus default: mean - 1.8*sd, width 0.3*sd
impute_downshifted <- function(x) {
  observed <- x[!is.na(x)]
  if (length(observed) < 2) return(x)

  mu_impute <- mean(observed) - 1.8 * sd(observed)
  sd_impute <- 0.3 * sd(observed)

  x[is.na(x)] <- rnorm(sum(is.na(x)), mean = mu_impute, sd = sd_impute)
  return(x)
}

imputed_data <- log_data %>%
  group_by(peptide) %>%
  mutate(log2_imputed = impute_downshifted(log2_abundance)) %>%
  ungroup()

# Step 3: t-test per peptide at 24h timepoint
conventional_results <- imputed_data %>%
  filter(timepoint == "24h") %>%
  group_by(peptide) %>%
  summarise(
    mean_ctrl = mean(log2_imputed[treatment == "ctrl"]),
    mean_drug = mean(log2_imputed[treatment == "drug"]),
    log2_fc = mean_drug - mean_ctrl,
    p_value = tryCatch(
      t.test(
        log2_imputed[treatment == "drug"],
        log2_imputed[treatment == "ctrl"]
      )$p.value,
      error = function(e) NA
    ),
    .groups = "drop"
  ) %>%
  mutate(
    fdr = p.adjust(p_value, method = "BH"),
    significant = fdr < 0.05
  )

# Merge with ground truth
conv_with_truth <- conventional_results %>%
  left_join(peptide_params %>% select(peptide, true_effect), by = "peptide")

# Calculate metrics
tp_conv <- sum(conv_with_truth$significant & conv_with_truth$true_effect, na.rm = TRUE)
fp_conv <- sum(conv_with_truth$significant & !conv_with_truth$true_effect, na.rm = TRUE)
fn_conv <- sum(!conv_with_truth$significant & conv_with_truth$true_effect, na.rm = TRUE)

cat("Log-transform + imputation + t-test Results (24h timepoint):\n")
cat("  True Positives:", tp_conv, "\n")
cat("  False Positives:", fp_conv, "\n")
cat("  False Negatives:", fn_conv, "\n")
cat("  Sensitivity:", round(tp_conv / (tp_conv + fn_conv), 3), "\n")
cat("  FDR:", round(fp_conv / (tp_conv + fp_conv), 3), "\n")
```

# Comparison: Complete Cases Only

A conservative approach: analyse only peptides with complete data at 24h, with no imputation.

```{r complete-cases}
# Identify peptides with complete data at 24h
complete_peptides <- dat$data %>%
  filter(timepoint == "24h") %>%
  group_by(peptide) %>%
  summarise(n_complete = sum(!is.na(value)), .groups = "drop") %>%
  filter(n_complete == 12) %>%  # 6 ctrl + 6 drug
  pull(peptide)

cat("Peptides with complete data at 24h:", length(complete_peptides), "\n")

# Analyse complete cases only
complete_results <- dat$data %>%
  filter(peptide %in% complete_peptides, timepoint == "24h") %>%
  group_by(peptide) %>%
  summarise(
    log2_fc = log2(mean(value[treatment == "drug"]) /
                   mean(value[treatment == "ctrl"])),
    p_value = tryCatch(
      wilcox.test(
        value[treatment == "drug"],
        value[treatment == "ctrl"]
      )$p.value,
      error = function(e) NA
    ),
    .groups = "drop"
  ) %>%
  mutate(
    fdr = p.adjust(p_value, method = "BH"),
    significant = fdr < 0.05
  )

# Merge with ground truth
complete_with_truth <- complete_results %>%
  left_join(peptide_params %>% select(peptide, true_effect), by = "peptide")

# Calculate metrics
tp_complete <- sum(complete_with_truth$significant & complete_with_truth$true_effect, na.rm = TRUE)
fp_complete <- sum(complete_with_truth$significant & !complete_with_truth$true_effect, na.rm = TRUE)
fn_complete <- sum(!complete_with_truth$significant & complete_with_truth$true_effect, na.rm = TRUE)

# Note: need to account for true positives excluded due to missingness
tp_excluded <- sum(peptide_params$true_effect & !peptide_params$peptide %in% complete_peptides)
fn_complete <- fn_complete + tp_excluded

cat("Complete Cases Only Results (24h timepoint):\n")
cat("  Peptides tested:", length(complete_peptides), "\n")
cat("  True positives excluded by missingness:", tp_excluded, "\n")
cat("  True Positives:", tp_complete, "\n")
cat("  False Positives:", fp_complete, "\n")
cat("  False Negatives:", fn_complete, "\n")
cat("  Sensitivity:", round(tp_complete / (tp_complete + fn_complete), 3), "\n")
if ((tp_complete + fp_complete) > 0) {
  cat("  FDR:", round(fp_complete / (tp_complete + fp_complete), 3), "\n")
}
```

# Comparison: Pooled Pairwise (Ignoring Timepoint)

An unstratified pairwise comparison that pools across all timepoints, ignoring the factorial structure.

**Important context:** Because this simulation includes treatment effects only at the 24h timepoint, pooling data across all timepoints (0h, 6h, 24h) dilutes the signal from 24h with the null results from 0h and 6h. This result illustrates the importance of matching analysis to experimental design. In experiments where effects are consistent across timepoints, pooled analysis would be appropriate.

```{r pairwise-pooled}
results_pairwise <- compare(
  dat,
  compare = "treatment",
  ref = "ctrl",
  method = "pairwise",
  test = "wilcoxon"
)

print(results_pairwise)

# Merge with ground truth
pairwise_with_truth <- results_pairwise$results %>%
  left_join(peptide_params %>% select(peptide, true_effect), by = "peptide")

# Calculate metrics
tp_pairwise <- sum(pairwise_with_truth$significant & pairwise_with_truth$true_effect, na.rm = TRUE)
fp_pairwise <- sum(pairwise_with_truth$significant & !pairwise_with_truth$true_effect, na.rm = TRUE)
fn_pairwise <- sum(!pairwise_with_truth$significant & pairwise_with_truth$true_effect, na.rm = TRUE)

cat("Pooled Pairwise Results (ignoring timepoint):\n")
cat("  True Positives:", tp_pairwise, "\n")
cat("  False Positives:", fp_pairwise, "\n")
cat("  False Negatives:", fn_pairwise, "\n")
cat("  Sensitivity:", round(tp_pairwise / (tp_pairwise + fn_pairwise), 3), "\n")
if ((tp_pairwise + fp_pairwise) > 0) {
  cat("  FDR:", round(fp_pairwise / (tp_pairwise + fp_pairwise), 3), "\n")
} else {
  cat("  FDR: undefined (no positives)\n")
}
```

# Method Comparison Summary

```{r method-comparison-table}
# Compile all metrics
comparison_metrics <- tibble(
  Method = c("Stratified GLM (pepdiff)", "Log2 + impute + t-test (Perseus)",
             "Complete cases only", "Pooled across timepoints"),
  `True Positives` = c(tp_glm, tp_conv, tp_complete, tp_pairwise),
  `False Positives` = c(fp_glm, fp_conv, fp_complete, fp_pairwise),
  `False Negatives` = c(fn_glm, fn_conv, fn_complete, fn_pairwise),
  Sensitivity = c(
    tp_glm / (tp_glm + fn_glm),
    tp_conv / (tp_conv + fn_conv),
    tp_complete / (tp_complete + fn_complete),
    tp_pairwise / (tp_pairwise + fn_pairwise)
  ),
  `FDR (observed)` = c(
    fp_glm / (tp_glm + fp_glm),
    fp_conv / (tp_conv + fp_conv),
    ifelse((tp_complete + fp_complete) > 0, fp_complete / (tp_complete + fp_complete), 0),
    ifelse((tp_pairwise + fp_pairwise) > 0, fp_pairwise / (tp_pairwise + fp_pairwise), NA)
  )
)

comparison_metrics %>%
  mutate(
    Sensitivity = round(Sensitivity, 3),
    `FDR (observed)` = round(`FDR (observed)`, 3)
  ) %>%
  knitr::kable(caption = "Method comparison at 24h timepoint. Sensitivity = TP/(TP+FN); FDR (observed) = proportion of detected positives that were false (FP/(TP+FP)), calculated against simulation ground truth. All methods used FDR < 0.05 as significance threshold.")
```

# Model Diagnostics

Using pepdiff's built-in `plot_fit_diagnostics()` function to assess GLM model fit.

```{r diagnostics, fig.width=10, fig.height=8}
diag <- plot_fit_diagnostics(results_glm)

# Show the diagnostic plot
print(diag$plot)

cat("\nNumber of flagged peptides:", nrow(diag$flagged), "\n")

if (nrow(diag$flagged) > 0) {
  # Check how many flagged peptides are true positives
  flagged_tp <- sum(diag$flagged$peptide %in%
                    peptide_params$peptide[peptide_params$true_effect])
  cat("Flagged peptides with true effect:", flagged_tp, "\n")

  # Show flagged peptides
  print(diag$flagged)
}
```

# ART Analysis for Comparison

The Aligned Rank Transform provides a non-parametric alternative when GLM diagnostics indicate poor fit.

```{r art-analysis}
results_art <- compare(
  dat,
  compare = "treatment",
  ref = "ctrl",
  within = "timepoint",
  method = "art"
)

print(results_art)

# Compare GLM vs ART for flagged peptides
if (nrow(diag$flagged) > 0) {
  flagged_comparison <- bind_rows(
    results_glm$results %>%
      filter(peptide %in% diag$flagged$peptide, timepoint == "24h") %>%
      mutate(method = "GLM"),
    results_art$results %>%
      filter(peptide %in% diag$flagged$peptide, timepoint == "24h") %>%
      mutate(method = "ART")
  ) %>%
    select(peptide, method, fold_change, p_value, fdr, significant) %>%
    pivot_wider(names_from = method, values_from = c(fold_change, p_value, fdr, significant))

  cat("\nComparison of GLM vs ART for flagged peptides:\n")
  print(flagged_comparison)
}
```

# Part 2: Pairwise Design Example

pepdiff also supports simple two-group comparisons without factorial structure. This section demonstrates the pairwise analysis workflow.

## Simulate Two-Group Data

```{r pairwise-simulate}
set.seed(2027)  # Different seed for independent simulation

n_pep_pairwise <- 200
n_tp_pairwise <- 30
n_reps_pairwise <- 8

# Generate peptide parameters
pairwise_params <- tibble(
  peptide = paste0("pw_", sprintf("%03d", 1:n_pep_pairwise)),
  gene_id = paste0("gene_", sprintf("%02d", rep(1:40, each = 5))),

  # Gamma distribution parameters
  shape = runif(n_pep_pairwise, 4, 10),
  rate = runif(n_pep_pairwise, 0.05, 0.12),

  # True effect for first 30 peptides (2-4 fold change)
  true_effect = c(rep(TRUE, n_tp_pairwise), rep(FALSE, n_pep_pairwise - n_tp_pairwise)),
  effect_size = ifelse(true_effect, runif(n_pep_pairwise, 2.0, 4.0), 1.0),

  # Missingness
  mean_abundance = shape / rate,
  miss_prob = pmax(0, 0.10 - 0.002 * mean_abundance)
)

cat("Pairwise simulation parameters:\n")
cat("  Total peptides:", n_pep_pairwise, "\n")
cat("  Peptides with true effect:", n_tp_pairwise, "\n")
cat("  Replicates per group:", n_reps_pairwise, "\n")

pairwise_params %>%
  group_by(true_effect) %>%
  summarise(
    n = n(),
    mean_effect_size = mean(effect_size),
    mean_miss_prob = mean(miss_prob),
    .groups = "drop"
  )
```

## Generate Data

```{r pairwise-generate}
# Create design grid (simple two-group)
pairwise_grid <- expand_grid(
  treatment = c("ctrl", "treatment"),
  bio_rep = 1:n_reps_pairwise
)

# Generate data
generate_pairwise_sample <- function(shape, rate, effect_size, miss_prob, treatment) {
  value <- rgamma(1, shape = shape, rate = rate)

  if (treatment == "treatment") {
    value <- value * effect_size
  }

  if (runif(1) < miss_prob) {
    value <- NA
  }

  return(value)
}

pairwise_data <- pairwise_params %>%
  crossing(pairwise_grid) %>%
  rowwise() %>%
  mutate(
    abundance = generate_pairwise_sample(shape, rate, effect_size, miss_prob, treatment)
  ) %>%
  ungroup() %>%
  select(peptide, gene_id, treatment, bio_rep, abundance)

cat("Total observations:", nrow(pairwise_data), "\n")
cat("Missing rate:", round(mean(is.na(pairwise_data$abundance)) * 100, 1), "%\n")

# Save for reproducibility
write_csv(pairwise_data, "simulated_pairwise.csv")
```

## Import and Analyse with pepdiff

```{r pairwise-import}
dat_pairwise <- read_pepdiff(
  "simulated_pairwise.csv",
  id = "peptide",
  gene = "gene_id",
  value = "abundance",
  factors = "treatment",
  replicate = "bio_rep"
)

print(dat_pairwise)
```

## Wilcoxon Rank-Sum Test

```{r pairwise-wilcoxon}
results_wilcox <- compare(
  dat_pairwise,
  compare = "treatment",
  ref = "ctrl",
  method = "pairwise",
  test = "wilcoxon"
)

print(results_wilcox)

# Validate against ground truth
wilcox_with_truth <- results_wilcox$results %>%
  left_join(pairwise_params %>% select(peptide, true_effect), by = "peptide")

tp_wilcox <- sum(wilcox_with_truth$significant & wilcox_with_truth$true_effect, na.rm = TRUE)
fp_wilcox <- sum(wilcox_with_truth$significant & !wilcox_with_truth$true_effect, na.rm = TRUE)
fn_wilcox <- sum(!wilcox_with_truth$significant & wilcox_with_truth$true_effect, na.rm = TRUE)

cat("Wilcoxon Rank-Sum Results:\n")
cat("  True Positives:", tp_wilcox, "\n")
cat("  False Positives:", fp_wilcox, "\n")
cat("  False Negatives:", fn_wilcox, "\n")
cat("  Sensitivity:", round(tp_wilcox / (tp_wilcox + fn_wilcox), 3), "\n")
cat("  FDR:", round(fp_wilcox / (tp_wilcox + fp_wilcox), 3), "\n")
```

## Bootstrap-t Test

```{r pairwise-bootstrap}
results_boot <- compare(
  dat_pairwise,
  compare = "treatment",
  ref = "ctrl",
  method = "pairwise",
  test = "bootstrap_t"
)

print(results_boot)

# Validate against ground truth
boot_with_truth <- results_boot$results %>%
  left_join(pairwise_params %>% select(peptide, true_effect), by = "peptide")

tp_boot <- sum(boot_with_truth$significant & boot_with_truth$true_effect, na.rm = TRUE)
fp_boot <- sum(boot_with_truth$significant & !boot_with_truth$true_effect, na.rm = TRUE)
fn_boot <- sum(!boot_with_truth$significant & boot_with_truth$true_effect, na.rm = TRUE)

cat("Bootstrap-t Results:\n")
cat("  True Positives:", tp_boot, "\n")
cat("  False Positives:", fp_boot, "\n")
cat("  False Negatives:", fn_boot, "\n")
cat("  Sensitivity:", round(tp_boot / (tp_boot + fn_boot), 3), "\n")
cat("  FDR:", round(fp_boot / (tp_boot + fp_boot), 3), "\n")
```

## Pairwise Methods Comparison

```{r pairwise-comparison}
pairwise_comparison <- tibble(
  Method = c("Wilcoxon rank-sum", "Bootstrap-t"),
  `True Positives` = c(tp_wilcox, tp_boot),
  `False Positives` = c(fp_wilcox, fp_boot),
  Sensitivity = c(
    tp_wilcox / (tp_wilcox + fn_wilcox),
    tp_boot / (tp_boot + fn_boot)
  ),
  `FDR (observed)` = c(
    fp_wilcox / (tp_wilcox + fp_wilcox),
    fp_boot / (tp_boot + fp_boot)
  )
)

pairwise_comparison %>%
  mutate(
    Sensitivity = round(Sensitivity, 3),
    `FDR (observed)` = round(`FDR (observed)`, 3)
  ) %>%
  knitr::kable(caption = "Pairwise test comparison (two-group design, 200 peptides, 30 with true effects). FDR (observed) = FP/(TP+FP) against ground truth; significance threshold FDR < 0.05.")
```

# Figure 1: Stratified Analysis Captures Timepoint-Specific Effects

## Panel A: Volcano Plots by Timepoint

```{r panel-a, fig.height=4, fig.width=10}
# Prepare data for all timepoints
all_timepoints_plot <- results_glm$results %>%
  left_join(peptide_params %>% select(peptide, true_effect), by = "peptide") %>%
  mutate(
    timepoint = factor(timepoint, levels = c("0h", "6h", "24h"))
  )

# Count significant peptides per timepoint for labels
sig_counts <- all_timepoints_plot %>%
  group_by(timepoint) %>%
  summarise(n_sig = sum(significant, na.rm = TRUE), .groups = "drop")

panel_a <- ggplot(all_timepoints_plot, aes(x = log2_fc, y = -log10(fdr))) +
  geom_point(aes(color = significant), alpha = 0.6, size = 1.5) +
  scale_color_manual(
    values = c("TRUE" = "#BD0026", "FALSE" = "grey70"),
    labels = c("TRUE" = "Significant", "FALSE" = "Not significant"),
    name = NULL
  ) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey40") +
  facet_wrap(~timepoint, ncol = 3) +
  labs(
    x = "log2 Fold Change (drug vs ctrl)",
    y = "-log10 FDR",
    title = "A. Treatment effects by timepoint"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0),
    strip.text = element_text(face = "bold", size = 11)
  )

print(panel_a)

cat("\nSignificant peptides by timepoint:\n")
print(sig_counts)
```

## Panel B: 24h Volcano with Ground Truth Annotation

```{r panel-b, fig.height=5, fig.width=6}
# Add ground truth to 24h results
res_24h_plot <- results_glm$results %>%
  filter(timepoint == "24h") %>%
  left_join(peptide_params %>% select(peptide, true_effect), by = "peptide") %>%
  mutate(
    point_type = case_when(
      significant & true_effect ~ "True positive",
      significant & !true_effect ~ "False positive",
      !significant & true_effect ~ "False negative",
      TRUE ~ "True negative"
    ),
    point_type = factor(point_type, levels = c("True positive", "False positive",
                                                "False negative", "True negative"))
  )

# Count each category
cat("\nClassification at 24h:\n")
print(table(res_24h_plot$point_type))

panel_b <- ggplot(res_24h_plot, aes(x = log2_fc, y = -log10(fdr))) +
  geom_point(aes(color = point_type), alpha = 0.7, size = 2) +
  scale_color_manual(
    values = c(
      "True positive" = "#BD0026",
      "False positive" = "#FD8D3C",
      "False negative" = "#2166AC",
      "True negative" = "grey70"
    ),
    name = NULL,
    drop = FALSE
  ) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey40") +
  labs(
    x = "log2 Fold Change (drug vs ctrl)",
    y = "-log10 FDR",
    title = "B. Validation at 24h timepoint"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0)
  ) +
  guides(color = guide_legend(nrow = 2, override.aes = list(size = 3)))

print(panel_b)
```

## Combine Panels into Figure 1

```{r figure-1, fig.width=10, fig.height=8}
figure_1 <- plot_grid(
  panel_a,
  panel_b,
  ncol = 1,
  rel_heights = c(1, 1.2),
  labels = NULL
)

print(figure_1)

# Save figure
ggsave("figure_1.pdf", figure_1, width = 10, height = 8)
ggsave("figure_1.png", figure_1, width = 10, height = 8, dpi = 300)
cat("\nFigure 1 saved to figure_1.pdf and figure_1.png\n")
```

# Supplementary Figure: Heatmap

```{r heatmap, fig.width=10, fig.height=12}
# Get significant peptides at 24h
sig_peptides <- results_glm$results %>%
  filter(significant, timepoint == "24h") %>%
  pull(peptide)

cat("Number of significant peptides at 24h:", length(sig_peptides), "\n")

if (length(sig_peptides) > 0) {
  # Create abundance matrix - mean per condition
  abundance_summary <- dat$data %>%
    filter(peptide %in% sig_peptides) %>%
    group_by(peptide, treatment, timepoint) %>%
    summarise(mean_abundance = mean(value, na.rm = TRUE), .groups = "drop")

  # Create wide format for z-scoring
  abundance_wide <- abundance_summary %>%
    unite("condition", treatment, timepoint, sep = "_") %>%
    pivot_wider(names_from = condition, values_from = mean_abundance)

  # Z-score normalise rows
  mat <- abundance_wide %>%
    column_to_rownames("peptide") %>%
    as.matrix()

  # Handle any remaining NAs
  mat[is.na(mat)] <- 0

  # Z-score each row
  mat_z <- t(apply(mat, 1, function(x) {
    if (sd(x, na.rm = TRUE) == 0) return(rep(0, length(x)))
    (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
  }))

  # Order columns logically
  col_order <- c("ctrl_0h", "ctrl_6h", "ctrl_24h", "drug_0h", "drug_6h", "drug_24h")
  col_order <- col_order[col_order %in% colnames(mat_z)]
  mat_z <- mat_z[, col_order]

  # Cluster rows
  if (nrow(mat_z) > 2) {
    row_order <- hclust(dist(mat_z))$order
    mat_z <- mat_z[row_order, ]
  }

  # Reshape for ggplot
  heatmap_data <- mat_z %>%
    as.data.frame() %>%
    rownames_to_column("peptide") %>%
    mutate(peptide = factor(peptide, levels = unique(peptide))) %>%
    pivot_longer(-peptide, names_to = "condition", values_to = "z_score") %>%
    mutate(condition = factor(condition, levels = col_order))

  # Add ground truth annotation
  heatmap_data <- heatmap_data %>%
    left_join(peptide_params %>% select(peptide, true_effect), by = "peptide")

  supp_heatmap <- ggplot(heatmap_data, aes(x = condition, y = peptide, fill = z_score)) +
    geom_tile() +
    scale_fill_gradient2(
      low = "#2166AC", mid = "white", high = "#BD0026",
      midpoint = 0, name = "Z-score",
      limits = c(-3, 3), oob = scales::squish
    ) +
    labs(
      x = "Condition",
      y = "Peptide",
      title = "Significant peptides across conditions",
      subtitle = paste(length(sig_peptides), "peptides significant at 24h timepoint")
    ) +
    theme_minimal() +
    theme(
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(face = "bold")
    )

  print(supp_heatmap)

  # Save heatmap
  ggsave("supplementary_heatmap.pdf", supp_heatmap, width = 8, height = 12)
  ggsave("supplementary_heatmap.png", supp_heatmap, width = 8, height = 12, dpi = 300)
  cat("\nHeatmap saved to supplementary_heatmap.pdf and supplementary_heatmap.png\n")
} else {
  cat("No significant peptides found - skipping heatmap\n")
}
```

# Session Information

```{r session-info}
sessionInfo()
```
